# Compute Shaders

В данном репозитории собраны мои эксперименты с Compute Shader'ами в Unity 6000.3.5f2. \
Compute Shader или же вычислительный шейдер - программа, работающая на GPU (видеокарте). Данная технология позволяет
очень хорошо оптимизировать тяжёлые в вычислениях, но простые в логике, программы.

В результате моего обучения я сделал (по возрастанию сложности):
1. Заполнение произвольной текстуры определенным цветом;
2. Заполнение произвольной текстуры каким-то рисунком, в моём случае - синусоидой;
3. Отображение Множества Мандельброта на текстуре;
4. Использование Compute Buffer для возведения чисел в квадрат;
5. Симуляция гигантского количества частиц на экране;
6. Симуляция Boid'ов.

Необходимо учитывать, что вычислительные шейдеры способны только производить вычисления, поэтому необходимо писать и обычные
шейдеры (вершинный и фрагментный) для отображения результатов.

## Заполнение текстуры
На данном этапе я только изучал азы вычислительных шейдеров и пытался реализовать
различные простые задачи. Этой простой задачей стала отрисовка на текстуру параллельно. \
Вычислительные шейдеры позволяют самому управлять ресурсами, требуемыми для реализации определенной задачи, в моём случае:
сколько потоков необходимо для эффективной работы.

Для отрисовки я выбрал numthreads(8,8,1) для эффективной итерации по 2D текстуре.
Как можно заметить, FPS держится в районе 100 на ноутбуке (Ryzen 7840HS, встроенная видеокарта)

Получившийся результат: \
![ComputeShaderTextures1.gif](Media/ComputeShaderTextures1.gif)

Цвет куба можно менять в реальном времени: \
![ComputeShaderTextures2.gif](Media/ComputeShaderTextures2.gif)

## Подсчёт квадратов чисел
Здесь необходимо положить все числа в определенный Compute Buffer (это буфер данных, хранящийся на GPU), из которого
видеокарта их возьмёт, посчитает, и вернёт обратно. \
![ComputeBufferVals.png](Media/ComputeBufferVals.png)

## Симуляция частиц
Здесь состояла задача симулировать частицы с определенной физикой. Для каждой частицы определена её позиция, скорость и 
цвет, которые передаются на видеокарту и читаются Compute и Vertex/Fragment shader'ами.

Без лагов и зависаний мой шейдер может отрендерить до **10 миллионов частиц** (учитывая непроизводительный ноутбук).

10.000.000 экземпляров рендерятся в 40 FPS, а 1.000.000 в 100-120 FPS. (Видео значительно снижает FPS)

![ComputeShaderParticles.gif](Media/ComputeShaderParticles.gif)

## Симуляция Boid'ов
Самая сложная и интересная задача одновременно: необходимо реализовать bird-oid объект, который будет имитировать
стайное поведение птиц.

В данном случае вычисления становятся намного тяжелее (и больше треугольников необходимо рендерить), поэтому FPS значительно
снижается, но всё ещё держится в очень приличном диапазоне.

У Boid'а есть 3 поведения:
1. Separation - должен избегать столкновения с сородичами
2. Alignment - направление полёта соседей должно совпадать
3. Cohesion - соседи должны держать центра массы стаи

Соседями являются Boid'ы, расстояние которых не превышает neighbourDistance и они могут видеть друг друга (fovAngle). \
Также, поведение определяется с помощью констант в шейдере: steerSpeed, maxVelocityMagnitude, minVelocityMagnitude и др.

![ComputeShaderBoids.gif](Media/ComputeShaderBoids.gif)

Как видно в демонстрации, FPS для отображения 15.000 boid'ов держался около 70-80 FPS, не считая съемку видео. 
Это демонстрирует высокую производительность и параллельность данного кода.